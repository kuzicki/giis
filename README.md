# Лабораторная работа №1

## Цель работы
Целью данной лабораторной работы является разработка элементарного графического редактора, который реализует построение отрезков с использованием трех различных алгоритмов:
- Алгоритм ЦДА (Цифровой дифференциальный анализатор)
- Целочисленный алгоритм Брезенхема
- Алгоритм Ву

Редактор должен включать в себя панель инструментов, позволяющую выбирать способ генерации отрезков, а также отладочный режим, в котором отображаются шаги построения отрезков на дискретной сетке.

## Задание
Разработать элементарный графический редактор, реализующий построение отрезков с помощью алгоритма ЦДА, целочисленного алгоритма Брезенхема и алгоритма Ву. Вызов способа генерации отрезка задается из пункта меню и доступно через панель инструментов «Отрезки». В редакторе кроме режима генерации отрезков в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение на дискретной сетке.

## Основные теоретические сведения

### Алгоритм ЦДА
ЦДА (Цифровой дифференциальный анализатор) — это метод, используемый для построения отрезков, который основан на вычислении изменений координат по мере продвижения отрезка от начальной точки к конечной. Алгоритм использует простые арифметические операции для вычисления промежуточных точек на сетке, что делает его достаточно быстрым, но менее точным при работе с вертикальными и горизонтальными отрезками.

### Алгоритм Брезенхема
Целочисленный алгоритм Брезенхема — это один из наиболее известных алгоритмов для построения отрезков на экране. Алгоритм используется для построения прямых линий на сетке пикселей, минимизируя количество вычислений и используя только целочисленные операции. Это делает его чрезвычайно быстрым для работы в реальном времени.

### Алгоритм Ву
Алгоритм Ву используется для построения отрезков с антиалиасингом, то есть с плавными переходами цвета. Он основан на вычислениях яркости пикселей и применении этих значений для сглаживания линии, что позволяет сделать линию более плавной и естественной, уменьшив эффект "зубцов", характерных для традиционных методов.

## Листинг кода
### Алгоритм ЦДА
```rust
pub fn dda_line(start: egui::Pos2, end: egui::Pos2) -> impl Iterator<Item = Vec<(Pixel, Pixel)>> {
    let length = (end.x - start.x).abs().max((end.y - start.y).abs());
    let dx = (end.x - start.x) / length;
    let dy = (end.y - start.y) / length;

    let (x_offset, y_offset) = (start.x.min(end.x), start.y.min(end.y));

    let mut x = start.x + 0.5 * sign(dx);
    let mut y = start.y + 0.5 * sign(dy);

    let mut i = 0.0;
    let first_value = std::iter::once(vec![(
        Pixel::new(x, y, 255),
        Pixel::new((x - x_offset).floor(), (y - y_offset).floor(), 255),
    )]);
    let func_iter = std::iter::from_fn(move || {
        if i <= length {
            let current = Pixel::new(x.floor(), y.floor(), 255);
            let debug = Pixel::new((x - x_offset).floor(), (y - y_offset).floor(), 255);
            x = x + dx;
            y = y + dy;
            i += 1.0;
            Some(vec![(current, debug)])
        } else {
            None
        }
    });

    first_value.chain(func_iter)
}

```

## Вывод
В ходе выполнения лабораторной работы был разработан графический редактор, реализующий построение отрезков с использованием трех алгоритмов: ЦДА, Брезенхема и Ву. Программа предоставляет удобный интерфейс с возможностью выбора алгоритма через меню и панель инструментов.  

Также реализован отладочный режим, позволяющий пошагово отслеживать процесс построения отрезков на дискретной сетке.  

В результате проведенных экспериментов было подтверждено, что:
- Алгоритм ЦДА прост в реализации, но менее точен при работе с крутыми углами.
- Алгоритм Брезенхема эффективен и быстр за счет использования целочисленной арифметики.
- Алгоритм Ву обеспечивает сглаживание линий, улучшая визуальное восприятие.  

Таким образом, работа позволила изучить и сравнить различные методы построения отрезков, их особенности и области применения.


# Лабораторная работа №2

## Цель работы
Целью данной лабораторной работы является разработка элементарного графического редактора, который реализует построение линий второго порядка:
- Окружность
- Эллипс
- Гипербола
- Парабола

Редактор должен включать в себя панель инструментов, позволяющую выбирать тип кривой, а также отладочный режим, в котором отображаются шаги построения на дискретной сетке.

## Задание
Разработать элементарный графический редактор, реализующий построение линий второго порядка: окружность, эллипс, гипербола, парабола. Выбор кривой задается из пункта меню и доступен через панель инструментов «Линии второго порядка». В редакторе кроме режима генерации линий второго порядка в пользовательском окне должен быть предусмотрен отладочный режим, где отображается пошаговое решение на дискретной сетке. 

## Основные теоретические сведения

### Алгоритм построения окружности
Один из наиболее известных алгоритмов построения окружности — это алгоритм Брезенхема. Он позволяет эффективно вычислять пиксели, принадлежащие окружности, используя целочисленные операции. Также можно использовать параметрическое или уравнение окружности в явном виде.

### Алгоритм построения эллипса
Для построения эллипса можно использовать модифицированный алгоритм Брезенхема, который адаптирован для эллиптических форм. Этот алгоритм позволяет минимизировать вычисления и строить эллипс с высокой скоростью.

### Алгоритм построения гиперболы
Гипербола может быть построена с использованием пошагового алгоритма, основанного на ее каноническом уравнении. Чаще всего используется метод на основе дифференциальных уравнений или дискретных итераций.

### Алгоритм построения параболы
Параболу можно построить с использованием пошагового метода, основанного на квадратном уравнении. Применяются аналогичные методы, как и для гиперболы, с учетом особенностей кривизны.

## Листинг кода
### Алгоритм отрисовки окружности
```rust
pub fn paint_circle(
    start: egui::Pos2,
    end: egui::Pos2,
) -> impl Iterator<Item = Vec<(Pixel, Pixel)>> {
    let mut x = 0;
    let r = start.distance(end) as i32;
    let mut y = r;
    let mut d = 2 - 2 * r;

    let (x_offset, y_offset) = (start.x.min(end.x), start.y.min(end.y));

    let func_iter = std::iter::from_fn(move || {
        if x <= y {
            let (old_x, old_y) = (x, y);
            x += 1;

            if d > 0 {
                y -= 1;
                d += 4 * (x - y) + 10;
            } else {
                d += 4 * x + 6;
            }
            Some(circle_sym(
                start,
                old_x,
                old_y,
                x_offset as i32,
                y_offset as i32,
                r,
            ))
        } else {
            None
        }
    });
    Box::new(func_iter)
}

```

## Вывод
В ходе выполнения лабораторной работы был разработан графический редактор, реализующий построение линий второго порядка: окружности, эллипса, гиперболы и параболы. Программа предоставляет удобный интерфейс с возможностью выбора типа кривой через меню и панель инструментов.  

Также реализован отладочный режим, позволяющий пошагово отслеживать процесс построения на дискретной сетке.  

В результате проведенных экспериментов было подтверждено, что:
- Алгоритм Брезенхема эффективен для построения окружностей и эллипсов.
- Гиперболы и параболы требуют более сложных вычислений и могут быть реализованы разными методами в зависимости от требований к точности и скорости.  

Таким образом, работа позволила изучить и сравнить различные методы построения линий второго порядка, их особенности и области применения.

# Лабораторная работа №3

## Цель работы
Целью данной лабораторной работы является изучение и реализация построения кривых с использованием различных методов, включая кривые Безье, B-сплайны и сплайны Эрмита.

В рамках работы необходимо:
- Разобраться с теоретическими основами построения кривых Безье, B-сплайнов и сплайнов Эрмита.
- Реализовать построение данных кривых на основе матричных представлений.
- Исследовать их свойства и особенности.

## Задание
Реализовать построение кривых с использованием различных методов:
- Кривые Безье.
- B-сплайны.
- Сплайны Эрмита.

Построение кривых должно быть реализовано в виде матричных представлений.
Для каждого метода необходимо визуализировать построенные кривые и продемонстрировать их свойства.
## Основные теоретические сведения

### Форма Эрмита

Форма Эрмита определяется контрольными точками и их производными (касательными). Это позволяет явно управлять направлением кривой в каждой точке.

Кубическая кривая Эрмита описывается уравнением:

$$
P(t) = H_0(t) P_0 + H_1(t) P_1 + H_2(t) T_0 + H_3(t) T_1,
$$

где $P_0$ и $P_1$ - опорные точки, $T_0$ и $T_1$ - касательные в этих точках, а $H_i(t)$ - базисные функции Эрмита:

$$
H_0(t) = 2t^3 - 3t^2 + 1,
$$

$$
H_1(t) = -2t^3 + 3t^2,
$$

$$
H_2(t) = t^3 - 2t^2 + t,
$$

$$
H_3(t) = t^3 - t^2.
$$

#### Матрица Эрмита

В матричной форме кривая Эрмита представляется так:

$$
\begin{bmatrix} x(t) \\ y(t) \\ z(t) \end{bmatrix} =
\begin{bmatrix} t^3 & t^2 & t & 1 \end{bmatrix}
\begin{bmatrix}
2 & -2 & 1 & 1 \\
-3 & 3 & -2 & -1 \\
0 & 0 & 1 & 0 \\
1 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ T_0 \\ T_1 \end{bmatrix}.
$$

### Кривые Безье

Кривые Безье используются для моделирования гладких кривых и широко применяются в компьютерной графике и анимации. Они определяются параметрическими уравнениями вида:

$$
P(t) = \sum_{i=0}^{n} B_i^n (t) P_i
$$

где $P_i$ - контрольные точки, а $B_i^n(t)$ - многочлены Бернштейна:

$$
B_i^n (t) = \binom{n}{i} t^i (1-t)^{n-i}, \quad 0 \leq t \leq 1.
$$



#### Матрица Безье

Для кубического случая ($n = 3$) можно представить кривую в матричной форме:

$$
\begin{bmatrix} x(t) \\ y(t) \\ z(t) \end{bmatrix} =
\begin{bmatrix} t^3 & t^2 & t & 1 \end{bmatrix}
\begin{bmatrix}
-1 & 3 & -3 & 1 \\
3 & -6 & 3 & 0 \\
-3 & 3 & 0 & 0 \\
1 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}.
$$

### B-сплайны

B-сплайны (Basis splines) — это обобщение кривых Безье, позволяющее строить гладкие кривые с помощью кусочно-полиномиальных функций.

Формула B-сплайнов:

$$
P(t) = \sum_{i=0}^{n} N_{i,k}(t) P_i,
$$

где $N_{i,k}(t)$ - базисные функции сплайна степени $k$, определяемые рекурсивно:

$$
N_{i,1}(t) = \begin{cases} 1, & t_i \leq t < t_{i+1} \\ 0, & \text{иначе} \end{cases},
$$

$$
N_{i,k}(t) = \frac{t - t_i}{t_{i+k-1} - t_i} N_{i,k-1}(t) + \frac{t_{i+k} - t}{t_{i+k} - t_{i+1}} N_{i+1,k-1}(t).
$$

#### Матрица B-сплайна (кубический случай)

Матрица кубического B-сплайна:

$$
\begin{bmatrix} x(t) \\ y(t) \\ z(t) \end{bmatrix} =
\begin{bmatrix} t^3 & t^2 & t & 1 \end{bmatrix}
\frac{1}{6} \begin{bmatrix}
-1 & 3 & -3 & 1 \\
3 & -6 & 3 & 0 \\
-3 & 0 & 3 & 0 \\
1 & 4 & 1 & 0
\end{bmatrix}
\begin{bmatrix} P_0 \\ P_1 \\ P_2 \\ P_3 \end{bmatrix}.
$$

## Вывод
В ходе выполнения лабораторной работы были изучены и реализованы три метода построения кривых: Безье, B-сплайны и сплайны Эрмита. Все методы были представлены в матричной форме, что позволило унифицировать их вычисление.

Результаты исследования показали, что:
- Сплайны Эрмита позволяют точно задать касательные направления в начальных и конечных точках.
- Кривые Безье дают удобное управление формой с помощью контрольных точек.
- B-сплайны обладают большей гибкостью за счет локального контроля формы.

Таким образом, работа позволила изучить принципы построения кривых и сравнить их свойства в различных приложениях.